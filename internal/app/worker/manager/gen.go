//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"html/template"
	"log"
	"os"
	"reflect"

	"dylaan.nl/netbox-deployer/internal/pkg/netbox"
)

const outputName = "detector_gen.go"

func main() {
	var buf bytes.Buffer

	fmt.Fprint(&buf, "// Code generated by \"gen.go\"; DO NOT EDIT.\n\n")
	fmt.Fprint(&buf, "package manager\n\n")
	fmt.Fprint(&buf, "import \"dylaan.nl/netbox-deployer/internal/pkg/netbox\"\n")

	genAllModelNames(&buf)

	err := os.WriteFile(outputName, buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func getUniqueModelTags(v any, uniqueTags map[string]struct{}) {
	val := reflect.ValueOf(v)

	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}

	if val.Kind() != reflect.Struct {
		return
	}

	t := val.Type()

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tag := field.Tag.Get("model")

		if tag != "" {
			uniqueTags[tag] = struct{}{}
		}

		fieldValue := val.Field(i)

		switch fieldValue.Kind() {
		case reflect.Struct:
			getUniqueModelTags(fieldValue.Interface(), uniqueTags)
		case reflect.Slice:
			for j := 0; j < fieldValue.Len(); j++ {
				getUniqueModelTags(fieldValue.Index(j).Interface(), uniqueTags)
			}
		}
	}
}

func allModelNames() []string {
	uniqueTags := make(map[string]struct{})
	getUniqueModelTags(netbox.VirtualMachine{}, uniqueTags)

	result := make([]string, 0, len(uniqueTags))
	for tag := range uniqueTags {
		result = append(result, tag)
	}
	return result
}

var allModelNamesTemplate = `
var allModelNames []netbox.ModelName

func init() {
	allModelNames = []netbox.ModelName {
		{{- range . }}
		netbox.ModelName("{{ . }}"),
		{{- end }}
	}
}`

func genAllModelNames(buf *bytes.Buffer) {
	tmpl, err := template.New("modelNames").Parse(allModelNamesTemplate)
	if err != nil {
		panic(err)
	}

	err = tmpl.Execute(buf, allModelNames())
	if err != nil {
		panic(err)
	}
}
